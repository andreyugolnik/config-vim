scriptencoding utf-8
" ^^ Please leave the above line at the start of the file.

"" ----------------------------------------------------------------------------
""
"" Andrey A. Ugolnik / _Andrey_
""
"" ----------------------------------------------------------------------------

let s:MSWindows = has('win95') + has('win16') + has('win32') + has('win64') + has('win32unix') + has('win64unix')

" on Windows use .vim instead vimfiles
if s:MSWindows
    set runtimepath=$HOME/.vim
    set runtimepath+=$VIM/vimfiles
    set runtimepath+=$VIMRUNTIME
    set runtimepath+=$VIM/vimfiles/after
    set runtimepath+=$HOME/.vim/after
endif

if has('vim_starting')
    " --- Use vim settings, rather then vi settings (much better!) ----------------
    " --- This must be first, because it changes other options as a side effect ---
    set nocompatible

    if s:MSWindows
        lan mes en_EN.UTF-8
        set langmenu=en_EN.UTF-8
    endif
endif

filetype off " required before vundle or pathogen

" -----------------------------------------------------------------------------
if empty(glob('~/.vim/autoload/plug.vim'))
    silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
                \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    autocmd VimEnter * PlugInstall
endif

call plug#begin('~/.vim/bundle')

" must have
Plug 'bling/vim-airline'
Plug 'a.vim', { 'for': ['c','cpp','objc','objcpp'] }
if s:MSWindows
    Plug 'Shougo/vimproc.vim', { 'do': 'make' }
    Plug 'Shougo/neocomplete.vim'
    Plug 'ctrlpvim/ctrlp.vim'
else
    Plug 'Valloric/YouCompleteMe', { 'for': [ 'c','cpp','objc','objcpp' ], 'do': './install.py --clang-completer' }
    Plug 'junegunn/fzf', { 'dir': '~/tools/fzf', 'do': './install --all' }
    Plug 'junegunn/fzf.vim'
endif
Plug 'SirVer/ultisnips'
Plug 'scrooloose/nerdcommenter'
Plug 'qpkorr/vim-bufkill' " delete buffer without killing windows layout
Plug 'rking/ag.vim' " very fast grep in files, depends on https://github.com/ggreer/the_silver_searcher
" very useful
Plug 'arecarn/crunch.vim' " calculate math with looser syntax support
Plug 'godlygeek/tabular'
Plug 'majutsushi/tagbar'
Plug 'mhinz/vim-signify'
Plug 'renamer.vim'
Plug 'scrooloose/syntastic', { 'for': ['c','cpp','objc','objcpp'] }
Plug 'spacehi.vim'
Plug 'TaskList.vim'
Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' }
Plug 'tpope/vim-fugitive'
Plug 'Chiel92/vim-autoformat'
Plug 'chrisbra/vim-diff-enhanced'
" Plug 'andreyugolnik/manpageview'
" Plug 'xolox/vim-misc'
" Plug 'xolox/vim-session'
Plug 'dart-lang/dart-vim-plugin', { 'for': ['dart'] }
Plug 'endel/actionscript.vim', { 'for': ['actionscript'] }
Plug 'noahfrederick/vim-skeleton', { 'for': ['c','cpp','objc','objcpp'] }

"Plug 'idanarye/vim-vebugger', { 'for': ['c','cpp','objc','objcpp'] }
"Plug 'tpope/vim-dispatch'
"Plug 'jeaye/color_coded', { 'do': 'cmake . && make && make install' }
"Plug 'derekwyatt/vim-protodef', { 'for': ['c','cpp'] }
"Plug 'derekwyatt/vim-fswitch', { 'for': ['c','cpp','objc','objcpp'] }
"Plug 'mtth/scratch.vim'
"Plug 'DoxygenToolkit.vim'

call plug#end()

" augroup load_snippets
    " autocmd!
    " autocmd InsertEnter * call plug#load('ultisnips')
                " \| autocmd! load_snippets
" augroup END

" if s:MSWindows
" else
" augroup load_ycm
    " autocmd!
    " autocmd InsertEnter *.c,*.cpp,*.h,*.m,*.mm,*.ino call plug#load('YouCompleteMe')
                " \| call youcompleteme#Enable() | autocmd! load_ycm
" augroup END
" endif

" -----------------------------------------------------------------------------

" --- enable detection, plugins and indenting in one step ---------------------
filetype plugin indent on

" -----------------------------------------------------------------------------

set t_Co=256

if v:version >= 704
    " The new Vim regex engine is currently slooooow as hell which makes syntax
    " highlighting slow, which introduces typing latency.
    " Consider removing this in the future when the new regex engine becomes
    " faster.
    set regexpengine=1
endif

" --- font used in Gvim -------------------------------------------------------
if has("gui_running")
    set guioptions-=T " disable toolbar
    set guioptions-=l " disable left scroolbar
    set guioptions-=L " disable left scroolbar
    set guioptions-=r " disable right scroolbar
    set guioptions-=R " disable right scroolbar
    set guioptions-=m " remove menubar
    set guioptions+=c " use console dialogs instead of popup dialogs for simple choices.
    set guioptions-=e " disable gui tabs

    " Русский текст для теста начертания символов
    if has("gui_macvim")
        set guifont=Menlo:h18
    elseif s:MSWindows
        set guifont=lucida_console:h14:cRUSSIAN
    else
        "set guifont=Pragmata\ 13
        set guifont=Droid\ Sans\ Mono\ 12
        "set guifont=Liberation\ Mono\ 12
        "set guifont=Inconsolata\ 13
        "set guifont=Bitstream\ Vera\ Sans\ Mono\ 13
        "set guifont=Monospace\ 9
    endif
    colorscheme Tomorrow-Night

    " nice theme collection available at
    " http://vimcolorschemetest.googlecode.com/svn/html/index-c.html
    "colorscheme torte
    "colorscheme asu1dark
    "colorscheme paintbox

    "set background=dark
    "colorscheme solarized

elseif (&t_Co == 256 || &t_Co == 88)
    colorscheme Tomorrow-Night
else
    colorscheme asmdev
endif

syntax on               " allow syntax highlighting

set title               " change the terminal's title
set showcmd             " display incomplete commands
set nobackup
set noswapfile
set viminfo='100,<50,s10,h,n~/.vim/viminfo
set autoread            " W11: autoread file after it changed outside vim

" highlight whitespaces in a convenient way
set list
"set listchars=tab:→\ ,trail:·,extends:»,nbsp:·,eol:¶
set listchars=tab:→\ ,trail:·,extends:»,nbsp:·
let c_space_errors=1    " Highlight any spaces before tabs, and any whitespace at the end of a line

set showmode            " always show what mode we're currently editing in
set hidden              " hides buffers instead of closing them
set switchbuf=useopen   " reveal already opened files from the quickfix window
                        " instead of opening new buffers
set nowrap              " don't wrap lines
set backspace=indent,eol,start          " allow backspacing over everything in insert mode
set ignorecase          " ignore case when searching
set smartcase           " ignore case if search pattern is all lowercase, case-sensitive otherwise
set incsearch           " show search matches as you type

set encoding=utf-8
set fencs=utf-8,ucs-bom,cp1251   " порядок перебора кодировок при открытии файла
set ffs=unix,dos        " порядок перебора fileformats
set cscopetag           " по Ctrl+] вести себя так же, как по g] (показывать варианты)
set lazyredraw          " don't update the display while executing macros

set tabstop=4           " number of spaces a <Tab> in the text stands for
set shiftwidth=4        " number of spaces used for each step of (auto)indent
set shiftround          " use multiple of shiftwidth when indenting with '<' and '>'
set expandtab           " expand <Tab> to spaces in Insert mode
set autoindent          " automatically set the indent of a new line
set copyindent          " copy the previous indentation on autoindenting
set smartindent         " do clever autoindenting
set cindent             " enable specific indenting for C code
"set showfulltag         " When completing by tag, show the whole tag, not just the function name
set diffopt+=iwhite     " Add ignorance of whitespace to diff
set smarttab            " insert tabs on the start of a line according to shiftwidth, not tabstop
set cino+=:0            " case: indent
set cino+=g0            " public: indent
set cino+=N-s           " namespace indent
set cino+=t0            " function return declaration
set cino+=(0            " unclosed prarntheses
"set cursorline          " highlight current line
set number              " show the line number for each line
"set mouse=a             " have the mouse enabled all the time
set formatoptions-=t    " don't auto-indent plaintext
set history=1024        " keep N lines of command history
set cc=80,100
set ruler               " show the cursor position all the time
set hlsearch            " highlight searches
set showmatch           " проверка скобок
set foldmethod=marker
"set foldopen&
"set foldclose=all
set popt+=syntax:y      " syntax when printing
set pastetoggle=<F10>   " mode that allow to paste text from clipboard without formating
set scrolloff=5         " rows number to show while scrolling
set laststatus=2        " always show status line
set clipboard=unnamedplus,unnamed

" complete options (disable preview scratch window)
"set completeopt=menuone,menu,longest,preview
set completeopt=menu,menuone,longest
set pumheight=15        " Limit popup menu height

" --- additional tags ---------------------------------------------------------
set tags+=./tags

" --- grep using AG -----------------------------------------------------------
" https://github.com/ggreer/the_silver_searcher
if executable('ag')
    set grepprg=ag\ --nogroup\ --nocolor
endif

" --- force filetype for some files -------------------------------------------
autocmd BufNewFile,BufRead *.m set filetype=objc
autocmd BufNewFile,BufRead *.mm set filetype=objcpp
autocmd BufNewFile,BufRead *.ino set filetype=cpp
autocmd BufNewFile,BufRead *.as set filetype=actionscript

" --- higlight word under cursor ----------------------------------------------
augroup AutoHighlight
    au!
    au CursorHold * exe printf('match IncSearch /\V\<%s\>/', escape(expand('<cword>'), '/\'))
    setlocal updatetime=300
augroup END

" --- enable cursor line only for current buffer ------------------------------
augroup CursorLine
    au!
    au VimEnter,WinEnter,BufWinEnter * setlocal cursorline
    au VimEnter,WinEnter,BufWinEnter *.xml setlocal nocursorline
    au WinLeave * setlocal nocursorline
augroup END

" --- higlight redundant tabs / spaces ----------------------------------------
autocmd BufNewFile,BufReadPost,FilterReadPost,FileReadPost,Syntax * SpaceHi
autocmd FileType help NoSpaceHi

" --- show git diff in split window -------------------------------------------
"autocmd FileType gitcommit DiffGitCached | wincmd p
"autocmd FileType gitcommit
    "\ if exists(':DiffGitCached') |
    "\   if ! &previewwindow && expand('%:t') !~# 'index' |
    "\     :DiffGitCached |
    "\   endif |
    "\ endif

"autocmd! BufRead,BufWrite,BufWritePost,BufNewFile *.org
"autocmd BufEnter *.org call org#SetOrgFileType()

" --- switch to us keyboard layout when insert mode leaved --------------------
autocmd InsertLeave *
    \ if has('unix') && &term == 'builtin_gui' |
    \   silent !qdbus ru.gentoo.KbddService /ru/gentoo/KbddService ru.gentoo.kbdd.set_layout 0 >/dev/null |
    \ endif

" --- always jump to the last cursor position "  ------------------------------
autocmd BufReadPost *
    \ if line("'\"") > 0 && line("'\"") <= line("$") |
    \    exe "normal g'\"" |
    \ endif

" --- clean trailing whitespace before write buffer ---------------------------
" autocmd BufWritePre * silent! execute '%s/\s\+$//'

" --- autoformat before write buffer ------------------------------------------
" autocmd BufWrite * :Autoformat

" --- redraw window at startup because lazyredraw prevent screen redraw -------
autocmd VimEnter * redraw

" --- persistent undo ---------------------------------------------------------
if v:version >= 703
    let s:undodir=$HOME.'/.vim/undofiles'

    if !isdirectory(s:undodir)
        call mkdir(s:undodir, 'p', 0700)
    endif

    set undofile " enable persistent undo
    let &undodir=s:undodir
endif
" -----------------------------------------------------------------------------



" --- ex command for toggling hex mode - define mapping if desired ------------
command! -bar Hexmode call ToggleHex()

" helper function to toggle hex mode
function! ToggleHex()
    " hex mode should be considered a read-only operation
    " save values for modified and read-only for restoration later,
    " and clear the read-only flag for now
    let l:modified=&mod
    let l:oldreadonly=&readonly
    let &readonly=0
    let l:oldmodifiable=&modifiable
    let &modifiable=1
    if !exists("b:editHex") || !b:editHex
        " save old options
        let b:oldft=&ft
        let b:oldbin=&bin
        " set new options
        setlocal binary " make sure it overrides any textwidth, etc.
        let &ft="xxd"
        " set status
        let b:editHex=1
        " switch to hex editor
        %!xxd
    else
        " restore old options
        let &ft=b:oldft
        if !b:oldbin
            setlocal nobinary
        endif
        " set status
        let b:editHex=0
        " return to normal editing
        %!xxd -r
    endif
    " restore values for modified and read only state
    let &mod=l:modified
    let &readonly=l:oldreadonly
    let &modifiable=l:oldmodifiable
endfunction

" --- folding -----------------------------------------------------------------
"nnoremap <Space> za
"vnoremap <Space> za

" --- new undo sequence on enter ----------------------------------------------
" inoremap <CR> <c-g>u<CR>

" --- use jk as <Esc> ---------------------------------------------------------
" inoremap jk <Esc>

" --- delete current buffer ---------------------------------------------------
nnoremap <leader>D :BD<CR>

" --- clean trailing whitespace -----------------------------------------------
nmap <silent> <leader>W :silent! %s/\s\+$//<CR>:let @/=''<CR>

" --- YCM go to defenition by semantic ----------------------------------------
nnoremap <leader>jd :YcmCompleter GoToDefinitionElseDeclaration<CR>

" --- toggle word under cursor ------------------------------------------------
" nnoremap <leader>tw :ToggleWord<CR>

" --- clears the search register ----------------------------------------------
nmap <silent> <space> :nohlsearch<CR>

" --- disable arrow keys ------------------------------------------------------
nnoremap <up> <nop>
nnoremap <down> <nop>
nnoremap <left> <nop>
nnoremap <right> <nop>
vnoremap <up> <nop>
vnoremap <down> <nop>
vnoremap <left> <nop>
vnoremap <right> <nop>
inoremap <up> <nop>
inoremap <down> <nop>
inoremap <left> <nop>
inoremap <right> <nop>

" --- navigate in command mode ------------------------------------------------
cnoremap <C-p> <Up>
cnoremap <C-n> <Down>

" --- useful movement in wrap mode --------------------------------------------
nnoremap j gj
nnoremap k gk

" --- перемещение по элементам в quickfix -------------------------------------
nnoremap <C-J> :cn<CR>zvzz:cc<CR>
nnoremap <C-K> :cp<CR>zvzz:cc<CR>

" --- simplified window navigation --------------------------------------------
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-h> <C-w>h
nnoremap <C-l> <C-w>l

" --- map ctrl-p to FZF file search -------------------------------------------
noremap <C-p> :FzfFiles<CR>
let g:fzf_command_prefix = 'Fzf'
let g:fzf_history_dir = $HOME.'/.vim/fzf-history'
let g:fzf_tags_command = 'ctags -R --sort=yes --c++-kinds=+p --fields=+liaS --extra=+q'

if executable('ag')

    let $FZF_DEFAULT_COMMAND = 'ag -l -g ""'

endif

" --- add highlighting for function definition in C++ -------------------------
autocmd Syntax cpp call EnhanceCppSyntax()
function! EnhanceCppSyntax()
    syn match cCustomParen   "(" contains=cParen contains=cCppParen
    syn match cCustomFunc    "\w\+\s*(" contains=cCustomParen
    syn match cppCustomScope "::"
    syn match cppCustomClass "\w\+\s*::" contains=cCustomScope
    hi def link cCustomFunc  Function
endfunction

" --- show / hide the line number for each line -------------------------------
imap <F1> <Esc>:set<Space>nu!<CR>a
nmap <F1>      :set<Space>nu!<CR>

" --- show / hide TagBar window ----------------------------------------------
nnoremap <leader>tb :TagbarToggle<CR>

" --- show / hide NERDTree window ---------------------------------------------
map <S-F2> <Esc>:NERDTreeToggle<CR>

" --- toggles the quickfix window ---------------------------------------------
map <silent><F2> <Esc>:QFix<CR>

let g:jah_Quickfix_Win_Height = 10

command! -bang -nargs=? QFix call QFixToggle(<bang>0)

function! QFixToggle(forced)
    if exists("g:qfix_win") && a:forced == 0
        cclose
    else
        execute "copen " . g:jah_Quickfix_Win_Height
    endif
endfunction

" used to track the quickfix window
augroup QFixToggle
    autocmd!
    autocmd BufWinEnter quickfix let g:qfix_win = bufnr("$")
    autocmd BufWinLeave * if exists("g:qfix_win") && expand("<abuf>") == g:qfix_win | unlet! g:qfix_win | endif
augroup END
" -----------------------------------------------------------------------------

" --- search world under cursor in all files with current ext -----------------
map <F4> <Esc>:GrepWordInFiles<CR>:cw<CR>
command! GrepWordInFiles :call s:GrepInFiles()
function! s:GrepInFiles()
    let s:word = expand("<cword>")

    let s:cft = &filetype

    if s:cft == "cpp" || s:cft == "c" || s:cft == "objc" || s:cft == "objcpp"
        "let s:mask = "*.h *.c *.cpp **/*.h **/*.c **/*.cpp **/*.ino"
        let s:mask = "--cpp --cc --objcpp --objc"
    else
        "let s:ext = expand("%:e")
        "let s:mask = "*" . (s:ext == "" ? "" : ".") . s:ext . " **/*" . (s:ext == "" ? "" : ".") . s:ext
        let s:mask = "--" . s:cft
    endif

    "execute "silent! noa vim! /\\<" . s:word . "\\>/gj " . s:mask | copen
    execute "Ag! " . s:mask . " " . s:word
endfunction

" --- apell checking ----------------------------------------------------------
"map <F7> :w!<CR>:!aspell -c --encoding=utf-8 --lang=ru %<CR>:e! %<CR>

" --- Makefile support --------------------------------------------------------
if has("mac")
    map <C-F9> <Esc>:make! osx<CR>
elseif s:MSWindows
    map <C-F9> <Esc>:make! win<CR>
else
    map <C-F9> <Esc>:make! linux<CR>
endif

map <C-F10> :make! run<CR>

" --- switch header / release -------------------------------------------------
map <F11> <Esc>:A<CR>

" --- create tags -------------------------------------------------------------
map <C-F12> <Esc>:MakeTags<CR>
command! MakeTags call MakeTagsFunction()
function! MakeTagsFunction()
    if executable('/usr/local/bin/ctags')
        !/usr/local/bin/ctags -R --sort=yes --c++-kinds=+p --fields=+liaS --extra=+q .
    else
        !ctags -R --sort=yes --c++-kinds=+p --fields=+liaS --extra=+q .
    endif
endfunction

" --- automaticaly insert a closing parenthesis when typing an opening --------
" --- parenthesis  ------------------------------------------------------------
"inoremap { {<CR>}<Esc>O
"inoremap ( ()<Esc>i
"inoremap [ []<Esc>i



" --- show encoding menu by F8 ------------------------------------------------
set wildmenu
set wcm=<Tab>
menu Encoding.utf-8        :e ++enc=utf-8 <CR>
menu Encoding.ucs-bom      :e ++enc=ucs-bom<CR>
menu Encoding.windows-1251 :e ++enc=cp1251<CR>
menu Encoding.koi8-r       :e ++enc=koi8-r<CR>
menu Encoding.ibm-866      :e ++enc=ibm866<CR>
map <F8> :emenu Encoding.<TAB>



" -----------------------------------------------------------------------------
"  common config
" -----------------------------------------------------------------------------
let Grep_Skip_Dirs = '.git .svn CVS .sass-cache'
" -----------------------------------------------------------------------------




" -----------------------------------------------------------------------------
" UltiSnips related config
" -----------------------------------------------------------------------------
let g:UltiSnipsExpandTrigger       = '<c-\>'
let g:UltiSnipsEnableSnipMate      = 1
let g:UltiSnipsSnippetsDir         = $HOME.'/.vim/snippets'
"let g:UltiSnipsJumpForwardTrigger  = '<c-j>'
"let g:UltiSnipsJumpBackwardTrigger = '<c-k>'
" -----------------------------------------------------------------------------




" -----------------------------------------------------------------------------
" neocomplete related config
" -----------------------------------------------------------------------------
if s:MSWindows
    " Disable AutoComplPop.
    let g:acp_enableAtStartup = 0
    " Use neocomplete.
    let g:neocomplete#enable_at_startup = 1
    " Use smartcase.
    let g:neocomplete#enable_smart_case = 1
    " Set minimum syntax keyword length.
    let g:neocomplete#sources#syntax#min_keyword_length = 3
    let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

    " Define dictionary.
    let g:neocomplete#sources#dictionary#dictionaries = {
                \ 'default' : '',
                \ 'vimshell' : $HOME.'/.vimshell_hist',
                \ }

    " Define keyword.
    if !exists('g:neocomplete#keyword_patterns')
        let g:neocomplete#keyword_patterns = {}
    endif
    let g:neocomplete#keyword_patterns['default'] = '\h\w*'

    " Plugin key-mappings.
    inoremap <expr><C-g>     neocomplete#undo_completion()
    inoremap <expr><C-l>     neocomplete#complete_common_string()

    " Recommended key-mappings.
    " <CR>: close popup and save indent.
    inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
    function! s:my_cr_function()
        return neocomplete#close_popup() . "\<CR>"
        " For no inserting <CR> key.
        "return pumvisible() ? neocomplete#close_popup() : "\<CR>"
    endfunction
    " <TAB>: completion.
    inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
    " <C-h>, <BS>: close popup and delete backword char.
    inoremap <expr><C-h>  neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><BS>   neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><C-y>  neocomplete#close_popup()
    inoremap <expr><C-e>  neocomplete#cancel_popup()
    " Close popup by <Space>.
    "inoremap <expr><Space> pumvisible() ? neocomplete#close_popup() : "\<Space>"

    " AutoComplPop like behavior.
    "let g:neocomplete#enable_auto_select = 1

    if !exists('g:neocomplete#force_omni_input_patterns')
        let g:neocomplete#force_omni_input_patterns = {}
    endif
    let g:neocomplete#force_overwrite_completefunc = 1
    let g:neocomplete#force_omni_input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)\w*'
    let g:neocomplete#force_omni_input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\w*\|\h\w*::\w*'
    let g:neocomplete#force_omni_input_patterns.objc = '\[\h\w*\s\h\?\|\h\w*\%(\.\|->\)'
    let g:neocomplete#force_omni_input_patterns.objcpp = '\[\h\w*\s\h\?\|\h\w*\%(\.\|->\)\|\h\w*::\w*'
    let g:clang_complete_auto = 0
    let g:clang_auto_select = 0
    let g:clang_use_library = 1
endif
" -----------------------------------------------------------------------------



" -----------------------------------------------------------------------------
" youcompleteme related config
" -----------------------------------------------------------------------------
let g:ycm_global_ycm_extra_conf               = $HOME.'/.vim/ycm_extra_conf.py'
let g:ycm_confirm_extra_conf                  = 0
let g:ycm_complete_in_comments                = 1
let g:ycm_complete_in_strings                 = 1
let g:ycm_echo_current_diagnostic             = 1
let g:ycm_enable_diagnostic_signs             = 1
let g:ycm_enable_diagnostic_highlighting      = 0
let g:ycm_collect_identifiers_from_tags_files = 0
let g:ycm_min_num_identifier_candidate_chars  = 0
let g:ycm_use_ultisnips_completer             = 1
" -----------------------------------------------------------------------------



" -----------------------------------------------------------------------------
" A.vim related config
" -----------------------------------------------------------------------------
let g:alternateExtensions_cpp = "h,H,hpp,HPP"
let g:alternateExtensions_CPP = "h,H,hpp,HPP"
let g:alternateExtensions_mm  = "h"
let g:alternateExtensions_m   = "h"
let g:alternateExtensions_c   = "h,H"
let g:alternateExtensions_C   = "h,H"
let g:alternateExtensions_h   = "cpp,mm,c,m,ino,CPP,C,INO"
let g:alternateExtensions_H   = "cpp,mm,c,m,ino,CPP,C,INO"
let g:alternateExtensions_hpp = "cpp,mm,c,ino,CPP,INO"
let g:alternateExtensions_HPP = "cpp,mm,c,ino,CPP,INO"
" -----------------------------------------------------------------------------



" -----------------------------------------------------------------------------
" syntastic related config
" -----------------------------------------------------------------------------
let g:syntastic_error_symbol         = '✖' " '✗'
let g:syntastic_warning_symbol       = '►' " '⚠'
let g:syntastic_style_error_symbol   = '⚡'
let g:syntastic_style_warning_symbol = '⚡'
let g:syntastic_mode_map             = {
            \ 'mode' : 'active',
            \ 'active_filetypes' : ['c', 'cpp', 'objc', 'objcpp'],
            \ 'passive_filetypes': ['']
            \ }
"let g:syntastic_c_include_dirs            = [ 'include', '../include' ]
"let g:syntastic_cpp_include_dirs          = [ 'include', '../include' ]
"let g:syntastic_cpp_remove_include_errors = 1
"let g:syntastic_cpp_compiler              = 'clang++'
"let g:syntastic_cpp_config_file           = $HOME.'/.vim/syntastic_cpp_config'

let g:syntastic_cpp_compiler_options = '-std=c++11
            \ -Wall -Wextra -Wshadow -Wpointer-arith
            \ -Wcast-align -Wwrite-strings -Wmissing-prototypes
            \ -Wmissing-declarations -Wredundant-decls -Wnested-externs
            \ -Winline -Wno-long-long -Wuninitialized -Wconversion
            \ -Wstrict-prototypes -pedantic'
let g:syntastic_tex_checkers         = ['lacheck']
let g:syntastic_c_compiler_options   = '-std=c11
            \ -Wall -Wextra -Wshadow -Wpointer-arith
            \ -Wcast-align -Wwrite-strings -Wmissing-prototypes
            \ -Wmissing-declarations -Wredundant-decls -Wnested-externs
            \ -Winline -Wno-long-long -Wuninitialized -Wconversion
            \ -Wstrict-prototypes -pedantic'
let g:syntastic_stl_format               = '[ = > ln:%F (%t)]'
let g:syntastic_aggregate_errors         = 1
let g:syntastic_enable_signs             = 1
let g:syntastic_auto_loc_list            = 2
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_c_no_include_search      = 1
let g:syntastic_c_auto_refresh_includes  = 1
let g:syntastic_c_check_header           = 1
" -----------------------------------------------------------------------------




" -----------------------------------------------------------------------------
"  Task List related config
" -----------------------------------------------------------------------------
let g:tlTokenList                 = ['todo', 'fixme']
let Tlist_Auto_Update             = 1
let Tlist_Close_On_Select         = 1
let Tlist_Exit_OnlyWindow         = 1
let Tlist_GainFocus_On_ToggleOpen = 1
" -----------------------------------------------------------------------------



" -----------------------------------------------------------------------------
" NERDTree related config
" -----------------------------------------------------------------------------
let NERDTreeIgnore = ['.*\.o$', '.*\~$', '.*\.out$', '.*\.so$', '.*\.a$']
let NERDTreeQuitOnOpen          = 1 " Quit on opening files from the tree
let NERDTreeHighlightCursorline = 1 " Highlight the selected entry in the tree
let NERDTreeChDirMode           = 2 " change working directory
let NERDTreeMinimalUI           = 1
" -----------------------------------------------------------------------------



" -----------------------------------------------------------------------------
" NERDCommenter related config
" -----------------------------------------------------------------------------
let g:NERDSpaceDelims = 1
" -----------------------------------------------------------------------------



" -----------------------------------------------------------------------------
" manpageview related options
" -----------------------------------------------------------------------------
let g:manpageview_options      = '-a'
let g:manpageview_multimanpage = 1
" -----------------------------------------------------------------------------



" -----------------------------------------------------------------------------
"  Session related config
" -----------------------------------------------------------------------------
let g:session_directory       = $HOME.'/.vim/sessions'
let g:session_autoload        = 'yes'
let g:session_autosave        = 'yes'
let g:session_default_to_last = 1
let g:session_command_aliases = 1 " Session commands starts from 'Session'
let g:session_persist_colors  = 0 " Prevent save the color scheme and the ‘background’ option
set sessionoptions-=help     " If you don't want help windows to be restored:
set sessionoptions-=options  " Don't persist options and mappings because it can corrupt sessions.
"set sessionoptions-=tabpages " If you only want to save the current tab page.
" -----------------------------------------------------------------------------



" -----------------------------------------------------------------------------
"  TagBar related config
" -----------------------------------------------------------------------------
let g:tagbar_left      = 1
let g:tagbar_width     = 30
let g:tagbar_autoclose = 1
let g:tagbar_autofocus = 1
let g:tagbar_compact   = 1
" -----------------------------------------------------------------------------



" -----------------------------------------------------------------------------
" doxygentoolkit related config
" -----------------------------------------------------------------------------
let g:DoxygenToolkit_authorName = "Andrey A. Ugolnik"
" -----------------------------------------------------------------------------



" -----------------------------------------------------------------------------
" CtrlP related config
" -----------------------------------------------------------------------------
"let g:ctrlp_dotfiles = 0

"When starting up, CtrlP sets its local working directory according to this
"variable:
  "c - the directory of the current file.
  "a - like "c", but only applies when the current working directory outside of
      "CtrlP isn't a direct ancestor of the directory of the current file.
  "r - the nearest ancestor that contains one of these directories or files:
      ".git .hg .svn .bzr _darcs
  "w - begin finding a root from the current working directory outside of CtrlP
      "instead of from the directory of the current file (default). Only applies
      "when "r" is also present.
  "0 or <empty> - disable this feature.
"let g:ctrlp_working_path_mode = 'ra'

" Set this to 1 to enable the lazy-update feature: only update the match window
" after typing's been stopped for a certain amount of time:
let g:ctrlp_lazy_update = 1

let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:20,results:100'

" Set this to 1 to set searching by filename (as opposed to full path)
let g:ctrlp_by_filename = 1

"let g:ctrlp_mruf_include = '\.h$|\.c$\|\.cpp$|\.m$|\.mm$'
let g:ctrlp_extensions = ['mixed']
let g:ctrlp_cmd = 'CtrlPMixed'

"unlet g:ctrlp_custom_ignore
let g:ctrlp_custom_ignore = {
            \ 'dir':  '\v[\/]\.(git|hg|svn)$|\v[\/](gen|bin|obj|build|libs|assets|tmp|temp)$',
            \ 'file': '\v\.(o|o\.d|so|dll|exe)$@<!$'
            \ }

let g:ctrlp_mruf_relative = 1 " MRU only in the current working directory.
let g:ctrlp_mruf_exclude = '' " exclude all MRU mask
let g:ctrlp_mruf_save_on_update = 0

if executable('ag')
    " Use ag in CtrlP for listing files. Lightning fast and respects .gitignore
    let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'

    " ag is fast enough that CtrlP doesn't need to cache
    let g:ctrlp_use_caching = 0
else
    " Ignore files in .gitignore
    let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files -co --exclude-standard']
endif

" -----------------------------------------------------------------------------



" -----------------------------------------------------------------------------
"  ErrorMarker related config
" -----------------------------------------------------------------------------
let &errorformat="%f:%l:%c: %t%*[^:]:%m,%f:%l: %t%*[^:]:%m," . &errorformat
" -----------------------------------------------------------------------------



" -----------------------------------------------------------------------------
" Java error format support by walker from LOR
" -----------------------------------------------------------------------------
set efm^=\ %#[javac]\ %#%f:%l:\ %m
" -----------------------------------------------------------------------------



" -----------------------------------------------------------------------------
"  AirLine related config
" -----------------------------------------------------------------------------
let g:airline_left_sep  = ''
let g:airline_right_sep = ''

if !exists('g:airline_symbols')
    let g:airline_symbols = {}
endif
let g:airline_symbols.paste = 'ρ'
if has("mac")
    let g:airline_symbols.branch   = '∫'
    let g:airline_symbols.readonly = '®'
    let g:airline_symbols.linenr   = '¶'
elseif s:MSWindows
    let g:airline_symbols.branch   = 'b'
    let g:airline_symbols.readonly = '-'
    let g:airline_symbols.linenr   = ''
else
    let g:airline_symbols.branch   = ''
    let g:airline_symbols.readonly = ''
    let g:airline_symbols.linenr   = '¶'
endif

let g:airline#extensions#tagbar#enabled = 1
let g:airline#extensions#branch#enabled = 1
" -----------------------------------------------------------------------------



" -----------------------------------------------------------------------------
"  AirLine related config
" -----------------------------------------------------------------------------
" let g:formatdef_astyle_c = '"astyle --mode=c --style=ansi -xC80 -U -j -k1 -m0 -xW -w -Y -pcH".(&expandtab ? "s".shiftwidth() : "t")'
let g:formatdef_astyle_c = '"astyle --mode=c --style=ansi -U -j -k1 -m0 -xW -w -Y -pcH".(&expandtab ? "s".shiftwidth() : "t")'
let g:formatters_c = ['astyle_c', 'clangformat']

let g:formatdef_astyle_cpp = g:formatdef_astyle_c
let g:formatters_cpp = ['astyle_cpp', 'clangformat']
" -----------------------------------------------------------------------------



" -----------------------------------------------------------------------------
"  Man related config
" -----------------------------------------------------------------------------
runtime! ftplugin/man.vim
let g:ft_man_open_mode = 'tab'
set keywordprg=:Man
autocmd FileType man setlocal nolist nonumber
" -----------------------------------------------------------------------------



" -----------------------------------------------------------------------------
"  Man related config
" -----------------------------------------------------------------------------
" started In Diff-Mode set diffexpr (plugin not loaded yet)
if &diff
    let &diffexpr='EnhancedDiff#Diff("git diff", "--diff-algorithm=patience")'
endif
